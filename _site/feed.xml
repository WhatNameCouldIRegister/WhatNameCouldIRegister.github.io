<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-18T15:20:36+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">DD’s tenique website</title><subtitle>Artificial Intelligence trends and concepts made easy.</subtitle><author><name>DD</name></author><entry><title type="html">CPP模板机制（1）</title><link href="http://localhost:4000/CPP%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6.html" rel="alternate" type="text/html" title="CPP模板机制（1）" /><published>2021-01-26T03:32:20+08:00</published><updated>2021-01-26T03:32:20+08:00</updated><id>http://localhost:4000/CPP%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6</id><content type="html" xml:base="http://localhost:4000/CPP%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6.html"><![CDATA[<p>主要结构 source from https://blog.csdn.net/JAN6055/article/details/123801017</p>

<h2 id="模板的声明方式">模板的声明方式</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// some demo
template &lt;typename T&gt;
T func(T A) {
    ...
}

templte &lt;typename T, template A&gt; 
T func(A a, T t) {
    ...
}

template &lt;typename T&gt;
class A {

};

//可变参数模板
template &lt;typename T, typename... Args&gt; 
T func(T a, Args...) {

}

</code></pre></div></div>

<h2 id="关于模板的工作机制">关于模板的工作机制</h2>
<ul>
  <li>首先我们要明确模板常常定义在头文件中，而由此也能练习到许多模板的作用机制。</li>
  <li>模板定义并不是真正的定义了一个函数或者类，而是编译器根据程序员缩写的模板和形参来自己写出一个对应版本的定义，这个过程叫做模板实例化。</li>
  <li>编译器成成的版本通常被称为模板的实例。编译器为程序员生成对应版本的具体过程。类似宏替换。模板类在没有调用之前是不会生成代码的。</li>
  <li>模板的实例化凭证是编译器遇到对模板的使用时才会生成相应版本的代码，这个时间是编译期</li>
  <li>为什么模板要放在头文件？试想当放在源文件中，当源文件中使用到模板代码，而模板定义在其他源文件中，那么此源文件无法找到函数地址，只能等待连接时刻。那如果其他源文件中不存在对模板的特定版本实例化代码怎么办呢？那么函数重定位就会失败，模板机制就会收到影响</li>
</ul>

<h2 id="非类型模板参数">非类型模板参数</h2>

<p>顾名思义，模板参数不是一个类型而是一个具体的值——这个值是常量表达式。</p>

<p>当一个模板被实例化时，，非类型参数被一个用户提供的或者编译器推断出的值所代替。正因为模板在编译阶段编译器为我们生成一个对应的版本，所以其值应该能够编译时确定，那么他应该是一个常量或者常量表达式。</p>

<p>有一句话说：C++的强大在于他的编译器强大，下面这个例子就是很好的说明。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
template &lt;size_t N, size_t M&gt;
int str_compare(const char (&amp;str1)[N], const char (&amp;str2)[M])
{
    return strcmp(str1,str2);
}

</code></pre></div></div>

<h2 id="模板默认参数">模板默认参数</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;typename T = int&gt;
class A {

};

//如果像下例实例化的模板默认A&lt;int&gt;类型
A&lt;&gt; a;
</code></pre></div></div>
<h2 id="类模板已经声明而成员函数希望在模板外实现的做法">类模板已经声明，而成员函数希望在模板外实现的做法</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;typename T&gt; 
class A {
    ...
    T func(T a) {
        ...
    }
    ...
};

//模板外实现
template &lt;typename T&gt;
T A::func(T a) {

}
</code></pre></div></div>

<h2 id="关于模板类的的模板成员">关于模板类的的模板成员</h2>

<p>我已经不知道用什么语言来下面的代码了。但是我们知道了一些事情。</p>

<p>无论是定义还是声明，模板语法的优先级是最高的，不同模板的优先级又根据其声明顺序来判断，其次是函数修饰，然后是返回值。根据这个原则我们可以轻松的解析这个函数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;typename T&gt; class A
{
public:
    template &lt;typename It&gt;  A&lt;T&gt; sum(It _begin, It _end);
};
 
template &lt;typename T&gt;        //最外层模板
template &lt;typename It&gt;       //内层模板
A&lt;T&gt;                         //返回值
A&lt;T&gt;::sum(It _begin, It _end)//函数标签 
{}                           //算法实现
 
//不妨写的更美观一点
template &lt;typename T&gt;
  template &lt;typename It&gt;
  A&lt;T&gt; A&lt;T&gt;::sum(It _begin, It _end){
      
  }
</code></pre></div></div>

<h2 id="模板实例化优化">模板实例化优化</h2>

<ul>
  <li>我们知道模板的实例化通常是以头文件为凭据，生成实例化代码，类似宏定义，那么当多个文件中都用到同样实例的代码就会存在多份函数拷贝</li>
  <li>解决这个问题，我们可以使用extern关键字,声明extern顾名思义就是告诉编译器在其他位置有相同的拷贝，请在链接阶段解决这个问题</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//导入其他文件中的模板实例
extern template class A&lt;T&gt;

//定义具体方式
template &lt;typename T&gt;
class B {

}
</code></pre></div></div>

<h2 id="遇到类型转换的时候会如何决策">遇到类型转换的时候会如何决策</h2>

<ul>
  <li>纵眼cpp，关于类型转换，我很赞同原文结构参考作者的观点：在转换是安全的情况下更有可能发生</li>
  <li>最经典的例子无非是 non-const 到 const 的转换</li>
  <li>下例中参数a的int会被增提转化为 const int, T推导为int</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template&lt;typename T&gt; 
bool func(const T t1, const T t2)
{
    return less&lt;T&gt;()(t1,t2);
}
 
...
 
    int a = 10;
    const int b = 20;
    func&lt;int&gt;(a,b);
</code></pre></div></div>

<p>这里的int转为cosnt int是允许的，因为这是按值传递，并且non-const 转为 cosnt也不会带来什么坏处。因此，编译器会执行这样的转换。</p>

<p>我们不妨修改一下这个函数</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool func(const T &amp; t1, const T &amp; t2);
bool func(T &amp; t1, T &amp; t2);

</code></pre></div></div>
<p>上述第一个声明会正常调用——虽然是引用，和上面的是同样的道理。</p>

<p>而第二个却不会正常调用——因为b是一个cosnt 将要转换为non-const，我中转换是不安全的，所以编译不允许这样的转换。</p>

<p>假设我们这样调用两个函数</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func&lt;int&gt;(10,20);
</code></pre></div></div>

<p>同样的，对于第一个是允许的——虽然讲右值绑定到左值引用上，但是我们用const修饰形参，保证其不会改变，所以编译器同意这样的转换。</p>

<p>而对于第二个，编译器则不允许这样的转换，因为我们的形参是non-const的，不能保证不修改形参的值，形参正好又是一个引用，这样可以修改实参的值——恰好实参是一个右值——是不允许被修改的，所以编译器不允许这样的转换。</p>

<p>基于上面的转换规则，我们可以知道，如果函数形参不是引用类型，则可以对数组或者函数类型的实参应用正常的指针转换。</p>

<h2 id="模板实参推断">模板实参推断</h2>

<p>直接上demo</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template &lt;typename T&gt; void func1(T &amp;) { }
template &lt;typename T&gt; void func2(const T &amp;) { }

void demo() {
    int a = 1
    const int b = 2;
    func1(a);   //T is int 
    func1(b);      //T is const int
    func2(a);      //T is int
    func2(b);      //T is int
    func2(10);     //T is int 
}
</code></pre></div></div>
<h2 id="下一篇主要涉及右值引用万能引用完美转发相关变长参数模板相关">下一篇主要涉及右值引用、万能引用、完美转发相关、变长参数模板相关</h2>
<p>…</p>]]></content><author><name>DD</name></author><category term="c++" /><category term="templates" /><summary type="html"><![CDATA[cpp模板常见混淆点做一个自我区分]]></summary></entry><entry><title type="html">CPP异常知识碎片</title><link href="http://localhost:4000/CPP%E5%BC%82%E5%B8%B8%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87.html" rel="alternate" type="text/html" title="CPP异常知识碎片" /><published>2021-01-26T03:32:20+08:00</published><updated>2021-01-26T03:32:20+08:00</updated><id>http://localhost:4000/CPP%E5%BC%82%E5%B8%B8%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87</id><content type="html" xml:base="http://localhost:4000/CPP%E5%BC%82%E5%B8%B8%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87.html"><![CDATA[<center><img src="./assets/img/posts/20220214/exception_list.png" width="480px" /></center>

<p>图片取自csdn @任我驰骋</p>

<p>首先异常全部继承自std::exception类
抓几个重要的来说，
std::bad_alloc在表征内存开辟错误
std::bad_cast 主要是dynamic_cast过程中抛出的错误。
logic_error 溢出、语义错误等
std::runtime_error 运行时错误，溢出错误</p>

<ul>
  <li>std::overflow_over</li>
  <li>std::range_error</li>
  <li>…</li>
</ul>

<p>异常捕捉的标准凭证是throw()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//异常处理标准流程

try {
} catch (Exception &amp;) {

}
</code></pre></div></div>

<p>关于异常处理的标准流程：</p>

<ul>
  <li>首先检查throw是否本身在try语句块内</li>
  <li>如果在则选择匹配的catch进行处理，如果没有找到匹配的catch或者本函数调用没有存在异常处理，递归地退出当前函数帧栈寻找catch解决，</li>
  <li>直到退出到main函数层面，如果依然没有匹配的处理模块那么就终止程序</li>
</ul>

<p><strong>异常安全</strong></p>

<p>构造函数完成对象的构造和初始化，最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有完全初始化</p>

<p>析构函数主要完成资源的清理，最好不要在析构函数内抛出异常，否则<strong>可能导致资源泄漏(</strong>内存泄漏、句柄未关闭等)</p>

<p>C++中异常经常会导致资源泄漏的问题，比如在new和del
ete中抛出了异常，导致内存泄漏，在lock和unlock之间抛出了异常导致死锁，C++经常使用RAII来解决以上问题。</p>

<p>异常抛出规范</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 这里表示这个函数会抛出A/B/C/D中的某种类型的异常
void fun() throw(A，B，C，D);
// 这里表示这个函数只会抛出bad_alloc的异常
void* operator new (std::size_t size) throw (std::bad_alloc);
</code></pre></div></div>

<p>更详细的观点链接： https://blog.csdn.net/mz474920631/article/details/125019151</p>

<p>异常的几个缺点记一下：比较重要的</p>
<ul>
  <li>程序乱跳</li>
  <li>C++没有垃圾回收，异常中没有正确处理申请的内存会很危险</li>
  <li>C++标准库的异常体系其实有点乱</li>
  <li>异常尽量规范使用，否则后果不堪设想，随意抛异常，外层捕获的用户苦不堪言。所以异常规范有两点：一、抛出异常类型都继承自一个基类。二、函数是否抛异常、抛什么异常，都使用 func（）throw();的方式规范化。</li>
</ul>]]></content><author><name>DD</name></author><category term="c++" /><category term="exeption" /><summary type="html"><![CDATA[CPP异常处理的处理逻辑与种类]]></summary></entry><entry><title type="html">STL相关的一些面试遭遇</title><link href="http://localhost:4000/STL%E7%9A%84%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93.html" rel="alternate" type="text/html" title="STL相关的一些面试遭遇" /><published>2021-01-26T03:32:20+08:00</published><updated>2021-01-26T03:32:20+08:00</updated><id>http://localhost:4000/STL%E7%9A%84%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/STL%E7%9A%84%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93.html"><![CDATA[<h2 id="stl的主要组成">STL的主要组成</h2>

<p>容器、算法、迭代器</p>

<h2 id="resize和reverse的区别">resize和reverse的区别</h2>

<ul>
  <li>改变的容器度量不一样。</li>
  <li>resize改变的是容器的size, 如果size大于容器原来的size，则扩大容器空间（size）并且将扩大的空间初始化</li>
  <li>reverse改变的是容器的capacity，要知道cap和size不是一个概念，cap表征容器已经开辟的空间，size代表元素的数量。cap理论上是大于等于size的，reverse的传参小于size的时候不会有事情发生，大于size的时候将capacity变化到传入参数指定的大小</li>
  <li>两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。</li>
</ul>

<h2 id="vector中at和访问区别">vector中at()和【】访问区别</h2>

<p>at会检查下标范围，【】访问如果下表越界会造成对内存的非法访问，at()更加安全。
at() 函数抛出的应当是std::out_of_range错误</p>]]></content><author><name>DD</name></author><category term="c++" /><category term="STL" /><category term="coding" /><summary type="html"><![CDATA[面试遇到的一些容器库的问题，持续更新]]></summary></entry><entry><title type="html">关于虚函数的一些再确认</title><link href="http://localhost:4000/%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E7%90%86%E8%A7%A3.html" rel="alternate" type="text/html" title="关于虚函数的一些再确认" /><published>2021-01-26T03:32:20+08:00</published><updated>2021-01-26T03:32:20+08:00</updated><id>http://localhost:4000/%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E7%90%86%E8%A7%A3</id><content type="html" xml:base="http://localhost:4000/%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E7%90%86%E8%A7%A3.html"><![CDATA[<ul>
  <li>虚函数表是类的</li>
  <li>类的每个对象前四个字节就是指向虚函数表的指针</li>
  <li>虚函数表的内容是指向函数的指针</li>
</ul>

<p>父类指针指向子类对象。运行时动态多态机制。指针指向的内存地址是派生类，根据派生类对象前四个字节找到虚函数表指针，根据虚函数表指针找到虚函数表从而调用函数</p>

<h3 id="哪些函数不能被声明为虚函数">哪些函数不能被声明为虚函数</h3>
<p>常见的不不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。</p>

<h3 id="为什么c不支持普通函数为虚函数">为什么C++不支持普通函数为虚函数？</h3>
<p>普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。</p>

<h3 id="为什么c不支持构造函数为虚函数">为什么C++不支持构造函数为虚函数？</h3>
<p>这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。 构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成，所以不能将构造函数定义为虚函数。</p>

<h3 id="为什么c不支持内联成员函数为虚函数">为什么C++不支持内联成员函数为虚函数？</h3>
<p>其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数） 内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数。</p>

<h3 id="为什么c不支持静态成员函数为虚函数">为什么C++不支持静态成员函数为虚函数？</h3>
<p>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。 静态成员函数属于一个类而非某一对象，没有this指针，它无法进行对象的判别。  为什么C++不支持友元函数为虚函数？ 因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</p>]]></content><author><name>DD</name></author><category term="c++" /><category term="coding" /><summary type="html"><![CDATA[Single neuron perceptron that classifies elements learning quite quickly.]]></summary></entry></feed>