<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-22T21:38:40+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">DD’s tenique website</title><subtitle>Artificial Intelligence trends and concepts made easy.</subtitle><author><name>DD</name></author><entry><title type="html">CPP并发编程整理(1)</title><link href="http://localhost:4000/CPP%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%95%B4%E7%90%86.html" rel="alternate" type="text/html" title="CPP并发编程整理(1)" /><published>2021-01-26T03:32:20+08:00</published><updated>2021-01-26T03:32:20+08:00</updated><id>http://localhost:4000/CPP%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%95%B4%E7%90%86</id><content type="html" xml:base="http://localhost:4000/CPP%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%95%B4%E7%90%86.html"><![CDATA[<p>文章主要内容摘自： https://paul.pub/cpp-concurrency/</p>

<h1 id="why-并发编程">Why 并发编程</h1>

<ul>
  <li>所有任务串行处理效率低下</li>
  <li>虽然CPU处理频率在增长，但是终究会遇到突破的瓶颈。大家会发现曾经有过一段时间CPU的频率从3G到达4G，但在这之后就停滞不前了。因此最近的新款CPU也基本上都是3G左右的频率。相应的，CPU以更多核的形式在增长。目前的Intel i7有8核的版本，Xeon处理器达到了28核。并且，最近几年手机上使用的CPU也基本上是4核或者8核的了。掌握并发编程，可以真正地使处理器协调工作，并行完成任务，提高效率。</li>
</ul>

<h2 id="关于并发和并行">关于并发和并行</h2>

<ul>
  <li>并发concurrent，一段时间内执行多段任务，从宏观上来看是多任务同时完成的</li>
  <li>并行parallel，在某一个时刻，有多个任务在实际上同时执行</li>
</ul>

<p>更严格的来说：如果一个系统支持多个动作同时存在，那么这个系统就是一个并发系统。如果这个系统还支持多个动作（物理时间上）同时执行，那么这个系统就是一个并行系统。</p>

<p>你可能已经看出，“并行”其实是“并发”的子集。它们的区别在于是否具有多个处理器。如果存在多个处理器同时执行多个线程，就是并行。</p>

<p>在不考虑处理器数量的情况下，我们统称之为“并发”。</p>

<h3 id="多线程一定能提升效率么">多线程一定能提升效率么？</h3>
<p>但我们需要知道，单纯的使用多线程并不一定能提升系统性能（当然，也并非线程越多系统的性能就越好）。从上面的两幅图我们就可以直观的感受到：线程（任务）的数量要根据具体的处理器数量来决定。假设只有一个处理器，那么划分太多线程可能会适得其反。因为很多时间都花在任务切换上了。</p>

<h2 id="cpp的并发编程">CPP的并发编程</h2>

<p>知道cpp 11标准之前，c++标准库都没有对多线程编程的明确支持，如果在linux系统中需要使用linux的系统的api类似pthread_create来创建多线程环境，线程库叫POXIS THREAD</p>

<center><img src="./assets/img/posts/20230222/cpp_history.jpg" width="480px" /></center>

<h2 id="编译器与c标准">编译器与C++标准</h2>
<p>编译器对于语言特性的支持是逐步完成的。想要使用特定的特性你需要相应版本的编译器。</p>

<p>GCC对于C++特性的支持请参见这里：<a href="https://www.gnu.org/software/gcc/projects/cxx-status.html">C++ Standards Support in GCC</a>。
Clang对于C++特性的支持请参见这里：<a href="https://clang.llvm.org/cxx_status.html">C++ Support in Clang</a>。</p>

<p>关于cpp和gcc的版本对应关系，因为有线程库这样的类似的标志性变化，所以gcc的标志版本可以浅浅记一下</p>

<table>
  <thead>
    <tr>
      <th>cpp</th>
      <th>gcc</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>c++11</td>
      <td>4.8</td>
    </tr>
    <tr>
      <td>c++17</td>
      <td>5.0</td>
    </tr>
    <tr>
      <td>c++20</td>
      <td>7.0</td>
    </tr>
  </tbody>
</table>

<p>默认情况下编译器是以较低的标准来进行编译的，如果希望使用新的标准，你需要通过编译参数-std=c++xx告知编译器，例如：</p>
<blockquote>
  <p>g++ -std=c++17 your_file.cpp -o your_program</p>
</blockquote>

<h1 id="线程">线程</h1>

<h3 id="创建线程">创建线程</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 01_hello_thread.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="c1"> // ①</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> <span class="c1">// ②</span>

<span class="kt">void</span> <span class="nf">hello</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// ③</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello World from new thread."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">hello</span><span class="p">);</span> <span class="c1">// ④</span>
  <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span> <span class="c1">// ⑤</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>thread可以和callable类型一起工作，因此如果你熟悉lambda表达式，你可以直接用它来写线程的逻辑，像这样：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 02_lambda_thread.cpp

#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

int main() {
  thread t([] {
    cout &lt;&lt; "Hello World from lambda thread." &lt;&lt; endl;
  });

  t.join();

  return 0;
}

//传递参数给入口函数
// 03_thread_argument.cpp

void hello(string name) {
  cout &lt;&lt; "Welcome to " &lt;&lt; name &lt;&lt; endl;
}

int main() {
  thread t(hello, "https://paul.pub");
  t.join();

  return 0;
}
</code></pre></div></div>

<ul>
  <li>要注意参数是拷贝构造传入的，对于拷贝十分复杂的对象需要传指针引用，但是要注意对象的生存周期</li>
</ul>

<h2 id="join-与-detach">join 与 detach</h2>

<ul>
  <li>join：调用此接口时，当前线程会一直阻塞，直到目标线程执行完成（当然，很可能目标线程在此处调用之前就已经执行完成了，不过这不要紧）。因此，如果目标线程的任务非常耗时，你就要考虑好是否需要在主线程上等待它了，因此这很可能会导致主线程卡住。</li>
  <li>detach：detach是让目标线程成为守护线程（daemon threads）。一旦detach之后，目标线程将独立执行，即便其对应的thread对象销毁也不影响线程的执行。并且，你无法再与之通信。其实意思应当是让其父进程成为0号的init进程，子进程的线程执行资源和状态由init负责释放</li>
  <li>对于这两个接口，都必须是可执行的线程才有意义。你可以通过joinable()接口、查询是否可以对它们进行join或者detach。</li>
</ul>

<h2 id="线程管理常用api">线程管理常用api</h2>

<table>
  <thead>
    <tr>
      <th>api</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>yield</td>
      <td>任务快结束的时候希望出让处理器</td>
    </tr>
    <tr>
      <td>get_id</td>
      <td>返回当前线程id</td>
    </tr>
    <tr>
      <td>sleep_for</td>
      <td>睡眠一定是时间</td>
    </tr>
    <tr>
      <td>sleep_until</td>
      <td>睡眠到指定时间</td>
    </tr>
  </tbody>
</table>

<h2 id="一次调用">一次调用</h2>
<p>主要API
|API|主要作用|
|—|—|
| call_once | 即便在多线程环境下，也能保证只调用某个函数一次 |
| once_flag |与call_once配合使用 |
在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化任务。这个时候就可以用到上面的接口。这个接口会保证，即便在多线程的环境下，相应的函数也只会调用一次。</p>

<p>下面就是一个示例：有三个线程都会使用init函数，但是只会有一个线程真正执行它。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 05_call_once.cpp</span>

<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Initialing..."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">// Do something...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">worker</span><span class="p">(</span><span class="n">once_flag</span><span class="o">*</span> <span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">call_once</span><span class="p">(</span><span class="o">*</span><span class="n">flag</span><span class="p">,</span> <span class="n">init</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">once_flag</span> <span class="n">flag</span><span class="p">;</span>

  <span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flag</span><span class="p">);</span>
  <span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flag</span><span class="p">);</span>
  <span class="kr">thread</span> <span class="n">t3</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flag</span><span class="p">);</span>

  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="n">t3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>我们无法确定具体是哪一个线程会执行init。而事实上，我们也不关心，因为只要有某个线程完成这个初始化工作就可以了。</p>]]></content><author><name>DD</name></author><category term="c++" /><category term="Parallel" /><category term="Concurrent" /><summary type="html"><![CDATA[cpp模板常见混淆点做一个自我区分]]></summary></entry><entry><title type="html">CPP异常知识碎片</title><link href="http://localhost:4000/CPP%E5%BC%82%E5%B8%B8%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87.html" rel="alternate" type="text/html" title="CPP异常知识碎片" /><published>2021-01-26T03:32:20+08:00</published><updated>2021-01-26T03:32:20+08:00</updated><id>http://localhost:4000/CPP%E5%BC%82%E5%B8%B8%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87</id><content type="html" xml:base="http://localhost:4000/CPP%E5%BC%82%E5%B8%B8%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87.html"><![CDATA[<center><img src="./assets/img/posts/20220214/exception_list.png" width="480px" /></center>

<p>图片取自csdn @任我驰骋</p>

<p>首先异常全部继承自std::exception类
抓几个重要的来说，
std::bad_alloc在表征内存开辟错误
std::bad_cast 主要是dynamic_cast过程中抛出的错误。
logic_error 溢出、语义错误等
std::runtime_error 运行时错误，溢出错误</p>

<ul>
  <li>std::overflow_over</li>
  <li>std::range_error</li>
  <li>…</li>
</ul>

<p>异常捕捉的标准凭证是throw()</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//异常处理标准流程</span>

<span class="k">try</span> <span class="p">{</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div>

<p>关于异常处理的标准流程：</p>

<ul>
  <li>首先检查throw是否本身在try语句块内</li>
  <li>如果在则选择匹配的catch进行处理，如果没有找到匹配的catch或者本函数调用没有存在异常处理，递归地退出当前函数帧栈寻找catch解决，</li>
  <li>直到退出到main函数层面，如果依然没有匹配的处理模块那么就终止程序</li>
</ul>

<p><strong>异常安全</strong></p>

<p>构造函数完成对象的构造和初始化，最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有完全初始化</p>

<p>析构函数主要完成资源的清理，最好不要在析构函数内抛出异常，否则<strong>可能导致资源泄漏(</strong>内存泄漏、句柄未关闭等)</p>

<p>C++中异常经常会导致资源泄漏的问题，比如在new和del
ete中抛出了异常，导致内存泄漏，在lock和unlock之间抛出了异常导致死锁，C++经常使用RAII来解决以上问题。</p>

<p>异常抛出规范</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这里表示这个函数会抛出A/B/C/D中的某种类型的异常</span>
<span class="kt">void</span> <span class="nf">fun</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span><span class="n">A</span><span class="err">，</span><span class="n">B</span><span class="err">，</span><span class="n">C</span><span class="err">，</span><span class="n">D</span><span class="p">);</span>
<span class="c1">// 这里表示这个函数只会抛出bad_alloc的异常</span>
<span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="k">throw</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">);</span>
</code></pre></div></div>

<p>更详细的观点链接： https://blog.csdn.net/mz474920631/article/details/125019151</p>

<p>异常的几个缺点记一下：比较重要的</p>
<ul>
  <li>程序乱跳</li>
  <li>C++没有垃圾回收，异常中没有正确处理申请的内存会很危险</li>
  <li>C++标准库的异常体系其实有点乱</li>
  <li>异常尽量规范使用，否则后果不堪设想，随意抛异常，外层捕获的用户苦不堪言。所以异常规范有两点：一、抛出异常类型都继承自一个基类。二、函数是否抛异常、抛什么异常，都使用 func（）throw();的方式规范化。</li>
</ul>]]></content><author><name>DD</name></author><category term="c++" /><category term="exeption" /><summary type="html"><![CDATA[CPP异常处理的处理逻辑与种类]]></summary></entry><entry><title type="html">STL相关的一些面试遭遇</title><link href="http://localhost:4000/STL%E7%9A%84%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93.html" rel="alternate" type="text/html" title="STL相关的一些面试遭遇" /><published>2021-01-26T03:32:20+08:00</published><updated>2021-01-26T03:32:20+08:00</updated><id>http://localhost:4000/STL%E7%9A%84%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/STL%E7%9A%84%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93.html"><![CDATA[<h2 id="stl的主要组成">STL的主要组成</h2>

<p>容器、算法、迭代器</p>

<h2 id="resize和reverse的区别">resize和reverse的区别</h2>

<ul>
  <li>改变的容器度量不一样。</li>
  <li>resize改变的是容器的size, 如果size大于容器原来的size，则扩大容器空间（size）并且将扩大的空间初始化</li>
  <li>reverse改变的是容器的capacity，要知道cap和size不是一个概念，cap表征容器已经开辟的空间，size代表元素的数量。cap理论上是大于等于size的，reverse的传参小于size的时候不会有事情发生，大于size的时候将capacity变化到传入参数指定的大小</li>
  <li>两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。</li>
</ul>

<h2 id="vector中at和访问区别">vector中at()和【】访问区别</h2>

<p>at会检查下标范围，【】访问如果下表越界会造成对内存的非法访问，at()更加安全。
at() 函数抛出的应当是std::out_of_range错误</p>]]></content><author><name>DD</name></author><category term="c++" /><category term="STL" /><category term="coding" /><summary type="html"><![CDATA[面试遇到的一些容器库的问题，持续更新]]></summary></entry><entry><title type="html">关于虚函数的一些再确认</title><link href="http://localhost:4000/%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E7%90%86%E8%A7%A3.html" rel="alternate" type="text/html" title="关于虚函数的一些再确认" /><published>2021-01-26T03:32:20+08:00</published><updated>2021-01-26T03:32:20+08:00</updated><id>http://localhost:4000/%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E7%90%86%E8%A7%A3</id><content type="html" xml:base="http://localhost:4000/%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E7%90%86%E8%A7%A3.html"><![CDATA[<ul>
  <li>虚函数表是类的</li>
  <li>类的每个对象前四个字节就是指向虚函数表的指针</li>
  <li>虚函数表的内容是指向函数的指针</li>
</ul>

<p>父类指针指向子类对象。运行时动态多态机制。指针指向的内存地址是派生类，根据派生类对象前四个字节找到虚函数表指针，根据虚函数表指针找到虚函数表从而调用函数</p>

<h3 id="哪些函数不能被声明为虚函数">哪些函数不能被声明为虚函数</h3>
<p>常见的不不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。</p>

<h3 id="为什么c不支持普通函数为虚函数">为什么C++不支持普通函数为虚函数？</h3>
<p>普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。</p>

<h3 id="为什么c不支持构造函数为虚函数">为什么C++不支持构造函数为虚函数？</h3>
<p>这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。 构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成，所以不能将构造函数定义为虚函数。</p>

<h3 id="为什么c不支持内联成员函数为虚函数">为什么C++不支持内联成员函数为虚函数？</h3>
<p>其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数） 内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数。</p>

<h3 id="为什么c不支持静态成员函数为虚函数">为什么C++不支持静态成员函数为虚函数？</h3>
<p>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。 静态成员函数属于一个类而非某一对象，没有this指针，它无法进行对象的判别。  为什么C++不支持友元函数为虚函数？ 因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</p>]]></content><author><name>DD</name></author><category term="c++" /><category term="coding" /><summary type="html"><![CDATA[Single neuron perceptron that classifies elements learning quite quickly.]]></summary></entry><entry><title type="html">CPP模板机制（1）</title><link href="http://localhost:4000/CPP%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6.html" rel="alternate" type="text/html" title="CPP模板机制（1）" /><published>2021-01-26T03:32:20+08:00</published><updated>2021-01-26T03:32:20+08:00</updated><id>http://localhost:4000/CPP%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6</id><content type="html" xml:base="http://localhost:4000/CPP%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6.html"><![CDATA[<p>主要结构 source from https://blog.csdn.net/JAN6055/article/details/123801017</p>

<h2 id="模板的声明方式">模板的声明方式</h2>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// some demo</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">func</span><span class="p">(</span><span class="n">T</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="n">templte</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">template</span> <span class="n">A</span><span class="p">&gt;</span> 
<span class="n">T</span> <span class="nf">func</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>

<span class="p">};</span>

<span class="c1">//可变参数模板</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> 
<span class="n">T</span> <span class="nf">func</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">Args</span><span class="p">...)</span> <span class="p">{</span>

<span class="p">}</span>

</code></pre></div></div>

<h2 id="关于模板的工作机制">关于模板的工作机制</h2>
<ul>
  <li>首先我们要明确模板常常定义在头文件中，而由此也能练习到许多模板的作用机制。</li>
  <li>模板定义并不是真正的定义了一个函数或者类，而是编译器根据程序员缩写的模板和形参来自己写出一个对应版本的定义，这个过程叫做模板实例化。</li>
  <li>编译器成成的版本通常被称为模板的实例。编译器为程序员生成对应版本的具体过程。类似宏替换。模板类在没有调用之前是不会生成代码的。</li>
  <li>模板的实例化凭证是编译器遇到对模板的使用时才会生成相应版本的代码，这个时间是编译期</li>
  <li>为什么模板要放在头文件？试想当放在源文件中，当源文件中使用到模板代码，而模板定义在其他源文件中，那么此源文件无法找到函数地址，只能等待连接时刻。那如果其他源文件中不存在对模板的特定版本实例化代码怎么办呢？那么函数重定位就会失败，模板机制就会收到影响</li>
</ul>

<h2 id="非类型模板参数">非类型模板参数</h2>

<p>顾名思义，模板参数不是一个类型而是一个具体的值——这个值是常量表达式。</p>

<p>当一个模板被实例化时，，非类型参数被一个用户提供的或者编译器推断出的值所代替。正因为模板在编译阶段编译器为我们生成一个对应的版本，所以其值应该能够编译时确定，那么他应该是一个常量或者常量表达式。</p>

<p>有一句话说：C++的强大在于他的编译器强大，下面这个例子就是很好的说明。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">M</span><span class="p">&gt;</span>
<span class="kt">int</span> <span class="nf">str_compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">str1</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">str2</span><span class="p">)[</span><span class="n">M</span><span class="p">])</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span><span class="n">str2</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="模板默认参数">模板默认参数</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">int</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>

<span class="p">};</span>

<span class="c1">//如果像下例实例化的模板默认A&lt;int&gt;类型</span>
<span class="n">A</span><span class="o">&lt;&gt;</span> <span class="n">a</span><span class="p">;</span>
</code></pre></div></div>
<h2 id="类模板已经声明而成员函数希望在模板外实现的做法">类模板已经声明，而成员函数希望在模板外实现的做法</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> 
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">T</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="c1">//模板外实现</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="n">A</span><span class="o">::</span><span class="n">func</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div>

<h2 id="关于模板类的的模板成员">关于模板类的的模板成员</h2>

<p>我已经不知道用什么语言来下面的代码了。但是我们知道了一些事情。</p>

<p>无论是定义还是声明，模板语法的优先级是最高的，不同模板的优先级又根据其声明顺序来判断，其次是函数修饰，然后是返回值。根据这个原则我们可以轻松的解析这个函数。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">&gt;</span>  <span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">It</span> <span class="n">_begin</span><span class="p">,</span> <span class="n">It</span> <span class="n">_end</span><span class="p">);</span>
<span class="p">};</span>
 
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>        <span class="c1">//最外层模板</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">&gt;</span>       <span class="c1">//内层模板</span>
<span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>                         <span class="c1">//返回值</span>
<span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sum</span><span class="p">(</span><span class="n">It</span> <span class="n">_begin</span><span class="p">,</span> <span class="n">It</span> <span class="n">_end</span><span class="p">)</span><span class="c1">//函数标签 </span>
<span class="p">{}</span>                           <span class="c1">//算法实现</span>
 
<span class="c1">//不妨写的更美观一点</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">It</span><span class="p">&gt;</span>
  <span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sum</span><span class="p">(</span><span class="n">It</span> <span class="n">_begin</span><span class="p">,</span> <span class="n">It</span> <span class="n">_end</span><span class="p">){</span>
      
  <span class="p">}</span>
</code></pre></div></div>

<h2 id="模板实例化优化">模板实例化优化</h2>

<ul>
  <li>我们知道模板的实例化通常是以头文件为凭据，生成实例化代码，类似宏定义，那么当多个文件中都用到同样实例的代码就会存在多份函数拷贝</li>
  <li>解决这个问题，我们可以使用extern关键字,声明extern顾名思义就是告诉编译器在其他位置有相同的拷贝，请在链接阶段解决这个问题</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//导入其他文件中的模板实例</span>
<span class="k">extern</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span>

<span class="c1">//定义具体方式</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div>

<h2 id="遇到类型转换的时候会如何决策">遇到类型转换的时候会如何决策</h2>

<ul>
  <li>纵眼cpp，关于类型转换，我很赞同原文结构参考作者的观点：在转换是安全的情况下更有可能发生</li>
  <li>最经典的例子无非是 non-const 到 const 的转换</li>
  <li>下例中参数a的int会被增提转化为 const int, T推导为int</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> 
<span class="kt">bool</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="n">t1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="n">t2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="p">...</span>
 
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="n">func</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</code></pre></div></div>

<p>这里的int转为cosnt int是允许的，因为这是按值传递，并且non-const 转为 cosnt也不会带来什么坏处。因此，编译器会执行这样的转换。</p>

<p>我们不妨修改一下这个函数</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="n">t1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="n">t2</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">func</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="n">t2</span><span class="p">);</span>

</code></pre></div></div>
<p>上述第一个声明会正常调用——虽然是引用，和上面的是同样的道理。</p>

<p>而第二个却不会正常调用——因为b是一个cosnt 将要转换为non-const，我中转换是不安全的，所以编译不允许这样的转换。</p>

<p>假设我们这样调用两个函数</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">func</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
</code></pre></div></div>

<p>同样的，对于第一个是允许的——虽然讲右值绑定到左值引用上，但是我们用const修饰形参，保证其不会改变，所以编译器同意这样的转换。</p>

<p>而对于第二个，编译器则不允许这样的转换，因为我们的形参是non-const的，不能保证不修改形参的值，形参正好又是一个引用，这样可以修改实参的值——恰好实参是一个右值——是不允许被修改的，所以编译器不允许这样的转换。</p>

<p>基于上面的转换规则，我们可以知道，如果函数形参不是引用类型，则可以对数组或者函数类型的实参应用正常的指针转换。</p>

<h2 id="模板实参推断">模板实参推断</h2>

<p>直接上demo</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">func1</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">func2</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">void</span> <span class="nf">demo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">func1</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>   <span class="c1">//T is int </span>
    <span class="n">func1</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>      <span class="c1">//T is const int</span>
    <span class="n">func2</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>      <span class="c1">//T is int</span>
    <span class="n">func2</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>      <span class="c1">//T is int</span>
    <span class="n">func2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>     <span class="c1">//T is int </span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="右值引用引用折叠万能引用">右值引用，引用折叠,万能引用</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 关于万能引用</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
<span class="n">func</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>  <span class="c1">//T被推导为int</span>
<span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">//T被推导成int&amp; </span>

</code></pre></div></div>
<h3 id="关于折叠和万能引用">关于折叠和万能引用</h3>

<p>众所周知在非模板函数中可以使用const &amp; 来接受任意类型参数，在模板中，也有类似这样的万能引用，就是&amp;&amp;。知道了这样的原因是有着引用折叠得的存在。</p>

<p>先说结论：在传递参数的过程中，无论多么复杂的引用传参，最后都会被折叠为&amp; 或者 &amp;&amp;。</p>

<p>这也就是引用折叠，引用折叠可以被概述成下列</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>如果我们间接创建了一个引用的引用，则这些引用形成折叠。除了右值引用的右值引用会被折叠为一个右值引用，剩下全部折叠为一个左值引用。即

T&amp; &amp;, T&amp; &amp;&amp;， T&amp;&amp; &amp;都会折叠为T&amp;

T&amp;&amp; &amp;&amp;会被折叠为&amp;&amp;

这两个规则又暗示了我们——我们可以将任意类型的实参传递给参数为右值引用的函数。
</code></pre></div></div>

<p>关于模板，上述的规则可以被统一为</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>如果一个函数参数是一个指向模板类型参数的右值引用，则他可以被绑定到一个左值。

如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数将被参数将被实例化为一个普通左值引用参数。
</code></pre></div></div>

<h2 id="stdmove">std::move</h2>
<p>直接上std::move定义</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">&amp;&amp;</span> <span class="n">move</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div></div>
<p>std::move通过用法我们知道它可以接受任何对象，因此他应当是一个模板。</p>

<h2 id="模板特例化">模板特例化</h2>
<p>我们编写的模板，不可能保证对于所有的类型都能适用——compare函数就是很经典的例子，对于两个指针类型，仅仅是毫无意义的比较。这时候我们用到模板特例化的技术可以很好的解决这样的问题。其实意思就是说，同一份类似宏定义的模板代码不一定能适配于所有版本的</p>

<p>由于less的底层是使用&lt;来比较的，所以less并没有适配字符指针。那么，我们可以编写这样的模板特例化。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>        <span class="c1">//表示一个模板特例化——语法规定</span>
<span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">str1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">str2</span><span class="p">)</span> <span class="c1">//具体的类型</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span><span class="n">str2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="特例化和重载的区别">特例化和重载的区别</h2>

<p>特例化就是一个特殊的实例化——模板的实例化，所以，特例化仅仅是模板的一个实例化，不会影响函数匹配。</p>

<p>并且，模板特例化一定要保证模板的之前的声明或者定义。如果不这样做——编译器不会报错，但是会有一些令人匪夷所思的地方。模板会由编译器实例化，而不是调用自己特例化版本——这种错误往往很难查找。所以，记住一个规则：特例化一个模板，一定要保证其在原模板的定义域中。</p>

<h2 id="部分模板特例化">部分模板特例化</h2>
<p>“针对模板参数更进一步的条件限制所设计出来的一个特化版本” （摘自《泛型思维》）</p>
<ul>
  <li>demo</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">//general template</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T2</span><span class="p">&gt;</span> 
<span class="k">class</span> <span class="nc">Pair</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span> 

 <span class="c1">//specialization with T2 set to int</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T1</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span>  <span class="p">{</span> <span class="p">...</span> <span class="p">};</span> 
</code></pre></div></div>

<h2 id="下一篇聚焦可变参数模板">下一篇聚焦可变参数模板</h2>
<p>…</p>]]></content><author><name>DD</name></author><category term="c++" /><category term="templates" /><summary type="html"><![CDATA[cpp模板常见混淆点做一个自我区分]]></summary></entry><entry><title type="html">CPP模板机制（2）</title><link href="http://localhost:4000/CPP%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6.html" rel="alternate" type="text/html" title="CPP模板机制（2）" /><published>2021-01-26T03:32:20+08:00</published><updated>2021-01-26T03:32:20+08:00</updated><id>http://localhost:4000/CPP%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6</id><content type="html" xml:base="http://localhost:4000/CPP%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6.html"><![CDATA[<p>主要结构 source from https://blog.csdn.net/JAN6055/article/details/123801017</p>

<p><strong><em>本篇主要整理可变参数模板</em></strong></p>

<h3 id="sizeof-运算符">sizeof… 运算符</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>  
<span class="kt">void</span> <span class="nf">var_fun</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//cout &lt;&lt; t;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"element numbers of packs is "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Args</span><span class="p">);</span>
    <span class="c1">//var_fun(args...);</span>
<span class="p">}</span>

</code></pre></div></div>
<p>能够获得包中参数的个数</p>

<h2 id="关于包拓展">关于包拓展</h2>
<p>是否对可变参数解析的省略号…用法存在疑虑？</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>拓展        packs expand

包拓展简单的来说将他分解为其构成的元素，如果说将参数变为包的过成类比为压缩未见，那么包拓展就是解压文件，但包拓展不仅仅是包展开。
</code></pre></div></div>
<p>我们知道了拓展包就是解析包内的元素，解析元素的过程在cpp的编译器处理中可以理解成对包内的元素进行分解，并且进行平行的操作。解包，就是在相应的操作后面加上…，编译器的处理逻辑就如上所述。
以下引用自原文的说法。</p>
<ul>
  <li>当拓展一个包时，我们还要提供用于，每个拓展元素的模式。拓展一个包就是将它分解为构成的元素，对每个元素应用模式，获得拓展后的列表。我们通过在模式右边防一个省略号…来触发拓展操作 。</li>
  <li>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>什么是模式？
在实际生活中，当我们说以一种模式打开某个东西，或者是什么模式打开时。指定的是固有的模式，比如说性能模式，均衡模式等。而包拓展的模式更像是对于每个元素都调用一次相应的函数，包拓展需要我们自定义模式——其实就是一个函数，返回值为包中的一个元素应用模式后的结果，所有这样的结果组合在一起，也就是包以这个模式（函数）展开。
</code></pre></div>    </div>
  </li>
</ul>

<p>以下引用自标准库的配置器展开</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>noexcept(noexcept(::new((void *)__p)
			    _Up(std::forward&lt;_Args&gt;(__args)...)))
</code></pre></div></div>
<p>另外，一定要注意省略号的位置，省略号的位置直接表述了对应解包的操作以及如何解包</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">var_func</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>      <span class="c1">//默认的包展开</span>
<span class="c1">//注释部分的...不为关键字，和C++语法没有任何关系</span>
<span class="c1">//相当于这样{ele1, ele2, ele3, ... ,elen}</span>
<span class="n">var_fun</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">args</span><span class="p">)...);</span>    <span class="c1">//带有模式的包展开</span>
<span class="c1">//第二种展开模式相当于这样</span>
<span class="c1">//{ mul(2,ele0),mul(2,ele1),mul(2,ele2), ... mul(2,elen) }</span>
</code></pre></div></div>
<p>所以其实并没有说…只能用于哪些函数和操作
在现代cpp中，…就代表了解包操作，编译器会根据…的使用来平行地应用模式</p>

<p><strong><em>还有个小细节，当你需要解包，…放在后面，当你为了压缩（其实可以类比一下，意思就是声明模板的传包形式时或者声明函数的可变参数传入形式时，…放在类似Args参数或者形式参数args前，注意仅仅是在参数前，在其他符号之后）</em></strong></p>

<h2 id="demo">demo</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span> <span class="p">,</span><span class="k">const</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
<span class="p">}</span>
 
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">int</span> <span class="nf">up</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">t</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">up</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="使用stdforward">使用std::forward</h2>
<p>要说转发一定离不开std::forward</p>

<p>forward返回实参类型的右值引用。它和move很像，但前者是返回给定类型的右值引用，如果给定的类型是左值引用也返回其右值引用——左值引用，并且其必须显式的指定模板参数；而move无论模板参数类型是什么都返回一个右值引用（只能是右值引用），因为前面已经看到了move的实现方法。</p>

<p>于是我们可以定义下面的转发函数</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">F</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">fun</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T1</span> <span class="o">&amp;&amp;</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">&amp;&amp;</span> <span class="n">t2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t2</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>
<p>使用右值引用作为模板参数——确保接受任意对象，并保证其能保持原来的性质不变（见引用折叠）。在发送参数的过程中获得对应类型的右值——确保其传递给函数的参数的性质不变（见引用折叠）。</p>

<h3 id="转发参数包">转发参数包</h3>

<p>根据上面转发的关键字，我们可以知道，在进行转发的时候应该以何种模式进行包展开。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template&lt;typename ... Args&gt;
void buffer_fun(Args &amp;&amp;... args)
{
    work(std::forward&lt;Args&gt;(args)...);
}
</code></pre></div></div>]]></content><author><name>DD</name></author><category term="c++" /><category term="templates" /><summary type="html"><![CDATA[cpp模板常见混淆点做一个自我区分]]></summary></entry></feed>