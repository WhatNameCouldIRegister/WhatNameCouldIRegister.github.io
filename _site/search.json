[
  
    {
      "title"       : "CPP模板机制（2）",
      "category"    : "",
      "tags"        : "c++, templates",
      "url"         : "./CPP%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6.html",
      "date"        : "2021-01-26 03:32:20 +0800",
      "description" : "cpp模板常见混淆点做一个自我区分",
      "content"     : "主要结构 source from https://blog.csdn.net/JAN6055/article/details/123801017本篇主要整理可变参数模板sizeof… 运算符template&lt;typename T, typename... Args&gt; void var_fun(const T &amp; t, const Args&amp;... args){ //cout &lt;&lt; t; cout &lt;&lt; \"element numbers of packs is \" &lt;&lt; sizeof...(Args); //var_fun(args...);}能够获得包中参数的个数关于包拓展是否对可变参数解析的省略号…用法存在疑虑？拓展 packs expand包拓展简单的来说将他分解为其构成的元素，如果说将参数变为包的过成类比为压缩未见，那么包拓展就是解压文件，但包拓展不仅仅是包展开。我们知道了拓展包就是解析包内的元素，解析元素的过程在cpp的编译器处理中可以理解成对包内的元素进行分解，并且进行平行的操作。解包，就是在相应的操作后面加上…，编译器的处理逻辑就如上所述。以下引用自原文的说法。 当拓展一个包时，我们还要提供用于，每个拓展元素的模式。拓展一个包就是将它分解为构成的元素，对每个元素应用模式，获得拓展后的列表。我们通过在模式右边防一个省略号…来触发拓展操作 。 什么是模式？在实际生活中，当我们说以一种模式打开某个东西，或者是什么模式打开时。指定的是固有的模式，比如说性能模式，均衡模式等。而包拓展的模式更像是对于每个元素都调用一次相应的函数，包拓展需要我们自定义模式——其实就是一个函数，返回值为包中的一个元素应用模式后的结果，所有这样的结果组合在一起，也就是包以这个模式（函数）展开。 以下引用自标准库的配置器展开noexcept(noexcept(::new((void *)__p) _Up(std::forward&lt;_Args&gt;(__args)...)))另外，一定要注意省略号的位置，省略号的位置直接表述了对应解包的操作以及如何解包var_func(args...); //默认的包展开//注释部分的...不为关键字，和C++语法没有任何关系//相当于这样{ele1, ele2, ele3, ... ,elen}var_fun(mul(2,args)...); //带有模式的包展开//第二种展开模式相当于这样//{ mul(2,ele0),mul(2,ele1),mul(2,ele2), ... mul(2,elen) }所以其实并没有说…只能用于哪些函数和操作在现代cpp中，…就代表了解包操作，编译器会根据…的使用来平行地应用模式还有个小细节，当你需要解包，…放在后面，当你为了压缩（其实可以类比一下，意思就是声明模板的传包形式时或者声明函数的可变参数传入形式时，…放在类似Args参数或者形式参数args前，注意仅仅是在参数前，在其他符号之后）demotemplate &lt;typename T&gt;void print(const T &amp; t){ cout &lt;&lt; t &lt;&lt; endl;}template &lt;typename T, typename... Args&gt;void print(const T &amp;t ,const Args... args){ cout &lt;&lt; t &lt;&lt; endl; print(args...);} template &lt;typename T&gt;int up(T &amp; t){ t *= 2; return t;}template &lt;typename... Args&gt;void func(Args&amp;&amp;... args){ print(up(args)...);} int main(){ func(1,2,3,4,5); return 0;}使用std::forward要说转发一定离不开std::forwardforward返回实参类型的右值引用。它和move很像，但前者是返回给定类型的右值引用，如果给定的类型是左值引用也返回其右值引用——左值引用，并且其必须显式的指定模板参数；而move无论模板参数类型是什么都返回一个右值引用（只能是右值引用），因为前面已经看到了move的实现方法。于是我们可以定义下面的转发函数template &lt;typename F, typename T1, typename T2&gt;void fun(F f, T1 &amp;&amp; t1, T2 &amp;&amp; t2){ f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));}使用右值引用作为模板参数——确保接受任意对象，并保证其能保持原来的性质不变（见引用折叠）。在发送参数的过程中获得对应类型的右值——确保其传递给函数的参数的性质不变（见引用折叠）。转发参数包根据上面转发的关键字，我们可以知道，在进行转发的时候应该以何种模式进行包展开。template&lt;typename ... Args&gt;void buffer_fun(Args &amp;&amp;... args){ work(std::forward&lt;Args&gt;(args)...);}"
    } ,
  
    {
      "title"       : "CPP模板机制（1）",
      "category"    : "",
      "tags"        : "c++, templates",
      "url"         : "./CPP%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6.html",
      "date"        : "2021-01-26 03:32:20 +0800",
      "description" : "cpp模板常见混淆点做一个自我区分",
      "content"     : "主要结构 source from https://blog.csdn.net/JAN6055/article/details/123801017模板的声明方式// some demotemplate &lt;typename T&gt;T func(T A) { ...}templte &lt;typename T, template A&gt; T func(A a, T t) { ...}template &lt;typename T&gt;class A {};//可变参数模板template &lt;typename T, typename... Args&gt; T func(T a, Args...) {}关于模板的工作机制 首先我们要明确模板常常定义在头文件中，而由此也能练习到许多模板的作用机制。 模板定义并不是真正的定义了一个函数或者类，而是编译器根据程序员缩写的模板和形参来自己写出一个对应版本的定义，这个过程叫做模板实例化。 编译器成成的版本通常被称为模板的实例。编译器为程序员生成对应版本的具体过程。类似宏替换。模板类在没有调用之前是不会生成代码的。 模板的实例化凭证是编译器遇到对模板的使用时才会生成相应版本的代码，这个时间是编译期 为什么模板要放在头文件？试想当放在源文件中，当源文件中使用到模板代码，而模板定义在其他源文件中，那么此源文件无法找到函数地址，只能等待连接时刻。那如果其他源文件中不存在对模板的特定版本实例化代码怎么办呢？那么函数重定位就会失败，模板机制就会收到影响非类型模板参数顾名思义，模板参数不是一个类型而是一个具体的值——这个值是常量表达式。当一个模板被实例化时，，非类型参数被一个用户提供的或者编译器推断出的值所代替。正因为模板在编译阶段编译器为我们生成一个对应的版本，所以其值应该能够编译时确定，那么他应该是一个常量或者常量表达式。有一句话说：C++的强大在于他的编译器强大，下面这个例子就是很好的说明。template &lt;size_t N, size_t M&gt;int str_compare(const char (&amp;str1)[N], const char (&amp;str2)[M]){ return strcmp(str1,str2);}模板默认参数template &lt;typename T = int&gt;class A {};//如果像下例实例化的模板默认A&lt;int&gt;类型A&lt;&gt; a;类模板已经声明，而成员函数希望在模板外实现的做法template &lt;typename T&gt; class A { ... T func(T a) { ... } ...};//模板外实现template &lt;typename T&gt;T A::func(T a) {}关于模板类的的模板成员我已经不知道用什么语言来下面的代码了。但是我们知道了一些事情。无论是定义还是声明，模板语法的优先级是最高的，不同模板的优先级又根据其声明顺序来判断，其次是函数修饰，然后是返回值。根据这个原则我们可以轻松的解析这个函数。template &lt;typename T&gt; class A{public: template &lt;typename It&gt; A&lt;T&gt; sum(It _begin, It _end);}; template &lt;typename T&gt; //最外层模板template &lt;typename It&gt; //内层模板A&lt;T&gt; //返回值A&lt;T&gt;::sum(It _begin, It _end)//函数标签 {} //算法实现 //不妨写的更美观一点template &lt;typename T&gt; template &lt;typename It&gt; A&lt;T&gt; A&lt;T&gt;::sum(It _begin, It _end){ }模板实例化优化 我们知道模板的实例化通常是以头文件为凭据，生成实例化代码，类似宏定义，那么当多个文件中都用到同样实例的代码就会存在多份函数拷贝 解决这个问题，我们可以使用extern关键字,声明extern顾名思义就是告诉编译器在其他位置有相同的拷贝，请在链接阶段解决这个问题//导入其他文件中的模板实例extern template class A&lt;T&gt;//定义具体方式template &lt;typename T&gt;class B {}遇到类型转换的时候会如何决策 纵眼cpp，关于类型转换，我很赞同原文结构参考作者的观点：在转换是安全的情况下更有可能发生 最经典的例子无非是 non-const 到 const 的转换 下例中参数a的int会被增提转化为 const int, T推导为inttemplate&lt;typename T&gt; bool func(const T t1, const T t2){ return less&lt;T&gt;()(t1,t2);} ... int a = 10; const int b = 20; func&lt;int&gt;(a,b);这里的int转为cosnt int是允许的，因为这是按值传递，并且non-const 转为 cosnt也不会带来什么坏处。因此，编译器会执行这样的转换。我们不妨修改一下这个函数bool func(const T &amp; t1, const T &amp; t2);bool func(T &amp; t1, T &amp; t2);上述第一个声明会正常调用——虽然是引用，和上面的是同样的道理。而第二个却不会正常调用——因为b是一个cosnt 将要转换为non-const，我中转换是不安全的，所以编译不允许这样的转换。假设我们这样调用两个函数func&lt;int&gt;(10,20);同样的，对于第一个是允许的——虽然讲右值绑定到左值引用上，但是我们用const修饰形参，保证其不会改变，所以编译器同意这样的转换。而对于第二个，编译器则不允许这样的转换，因为我们的形参是non-const的，不能保证不修改形参的值，形参正好又是一个引用，这样可以修改实参的值——恰好实参是一个右值——是不允许被修改的，所以编译器不允许这样的转换。基于上面的转换规则，我们可以知道，如果函数形参不是引用类型，则可以对数组或者函数类型的实参应用正常的指针转换。模板实参推断直接上demotemplate &lt;typename T&gt; void func1(T &amp;) { }template &lt;typename T&gt; void func2(const T &amp;) { }void demo() { int a = 1 const int b = 2; func1(a); //T is int func1(b); //T is const int func2(a); //T is int func2(b); //T is int func2(10); //T is int }右值引用，引用折叠,万能引用// 关于万能引用template &lt;typename T&gt;void func(T &amp;&amp;a) { ...}int a=10;func(10); //T被推导为intfunc(a); //T被推导成int&amp; 关于折叠和万能引用众所周知在非模板函数中可以使用const &amp; 来接受任意类型参数，在模板中，也有类似这样的万能引用，就是&amp;&amp;。知道了这样的原因是有着引用折叠得的存在。先说结论：在传递参数的过程中，无论多么复杂的引用传参，最后都会被折叠为&amp; 或者 &amp;&amp;。这也就是引用折叠，引用折叠可以被概述成下列如果我们间接创建了一个引用的引用，则这些引用形成折叠。除了右值引用的右值引用会被折叠为一个右值引用，剩下全部折叠为一个左值引用。即T&amp; &amp;, T&amp; &amp;&amp;， T&amp;&amp; &amp;都会折叠为T&amp;T&amp;&amp; &amp;&amp;会被折叠为&amp;&amp;这两个规则又暗示了我们——我们可以将任意类型的实参传递给参数为右值引用的函数。关于模板，上述的规则可以被统一为如果一个函数参数是一个指向模板类型参数的右值引用，则他可以被绑定到一个左值。如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数将被参数将被实例化为一个普通左值引用参数。std::move直接上std::move定义template &lt;typename T&gt;typename remove_reference&lt;T&gt;::type &amp;&amp; move(T &amp;&amp; t){ return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t); }std::move通过用法我们知道它可以接受任何对象，因此他应当是一个模板。模板特例化我们编写的模板，不可能保证对于所有的类型都能适用——compare函数就是很经典的例子，对于两个指针类型，仅仅是毫无意义的比较。这时候我们用到模板特例化的技术可以很好的解决这样的问题。其实意思就是说，同一份类似宏定义的模板代码不一定能适配于所有版本的由于less的底层是使用&lt;来比较的，所以less并没有适配字符指针。那么，我们可以编写这样的模板特例化。template &lt;&gt; //表示一个模板特例化——语法规定int compare(const char * const &amp; str1, const char * const &amp; str2) //具体的类型{ return strcmp(str1,str2);}特例化和重载的区别特例化就是一个特殊的实例化——模板的实例化，所以，特例化仅仅是模板的一个实例化，不会影响函数匹配。并且，模板特例化一定要保证模板的之前的声明或者定义。如果不这样做——编译器不会报错，但是会有一些令人匪夷所思的地方。模板会由编译器实例化，而不是调用自己特例化版本——这种错误往往很难查找。所以，记住一个规则：特例化一个模板，一定要保证其在原模板的定义域中。部分模板特例化“针对模板参数更进一步的条件限制所设计出来的一个特化版本” （摘自《泛型思维》） demo //general templatetemplate&lt;class T1, class T2&gt; class Pair { ... }; //specialization with T2 set to inttemplate&lt;class T1&gt;class Pair&lt;T1, int&gt; { ... }; 下一篇聚焦可变参数模板…"
    } ,
  
    {
      "title"       : "关于虚函数的一些再确认",
      "category"    : "",
      "tags"        : "c++, coding",
      "url"         : "./%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E7%90%86%E8%A7%A3.html",
      "date"        : "2021-01-26 03:32:20 +0800",
      "description" : "Single neuron perceptron that classifies elements learning quite quickly.",
      "content"     : "虚函数表是类的 类的每个对象前四个字节就是指向虚函数表的指针 虚函数表的内容是指向函数的指针父类指针指向子类对象。运行时动态多态机制。指针指向的内存地址是派生类，根据派生类对象前四个字节找到虚函数表指针，根据虚函数表指针找到虚函数表从而调用函数哪些函数不能被声明为虚函数常见的不不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。为什么C++不支持普通函数为虚函数？普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。为什么C++不支持构造函数为虚函数？这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。 构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成，所以不能将构造函数定义为虚函数。为什么C++不支持内联成员函数为虚函数？其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数） 内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数。为什么C++不支持静态成员函数为虚函数？这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。 静态成员函数属于一个类而非某一对象，没有this指针，它无法进行对象的判别。 为什么C++不支持友元函数为虚函数？ 因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。"
    } ,
  
    {
      "title"       : "STL相关的一些面试遭遇",
      "category"    : "",
      "tags"        : "c++, STL, coding",
      "url"         : "./STL%E7%9A%84%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93.html",
      "date"        : "2021-01-26 03:32:20 +0800",
      "description" : "面试遇到的一些容器库的问题，持续更新",
      "content"     : "STL的主要组成容器、算法、迭代器resize和reverse的区别 改变的容器度量不一样。 resize改变的是容器的size, 如果size大于容器原来的size，则扩大容器空间（size）并且将扩大的空间初始化 reverse改变的是容器的capacity，要知道cap和size不是一个概念，cap表征容器已经开辟的空间，size代表元素的数量。cap理论上是大于等于size的，reverse的传参小于size的时候不会有事情发生，大于size的时候将capacity变化到传入参数指定的大小 两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。vector中at()和【】访问区别at会检查下标范围，【】访问如果下表越界会造成对内存的非法访问，at()更加安全。at() 函数抛出的应当是std::out_of_range错误"
    } ,
  
    {
      "title"       : "CPP异常知识碎片",
      "category"    : "",
      "tags"        : "c++, exeption",
      "url"         : "./CPP%E5%BC%82%E5%B8%B8%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87.html",
      "date"        : "2021-01-26 03:32:20 +0800",
      "description" : "CPP异常处理的处理逻辑与种类",
      "content"     : "图片取自csdn @任我驰骋首先异常全部继承自std::exception类抓几个重要的来说，std::bad_alloc在表征内存开辟错误std::bad_cast 主要是dynamic_cast过程中抛出的错误。logic_error 溢出、语义错误等std::runtime_error 运行时错误，溢出错误 std::overflow_over std::range_error …异常捕捉的标准凭证是throw()//异常处理标准流程try {} catch (Exception &amp;) {}关于异常处理的标准流程： 首先检查throw是否本身在try语句块内 如果在则选择匹配的catch进行处理，如果没有找到匹配的catch或者本函数调用没有存在异常处理，递归地退出当前函数帧栈寻找catch解决， 直到退出到main函数层面，如果依然没有匹配的处理模块那么就终止程序异常安全构造函数完成对象的构造和初始化，最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有完全初始化析构函数主要完成资源的清理，最好不要在析构函数内抛出异常，否则可能导致资源泄漏(内存泄漏、句柄未关闭等)C++中异常经常会导致资源泄漏的问题，比如在new和delete中抛出了异常，导致内存泄漏，在lock和unlock之间抛出了异常导致死锁，C++经常使用RAII来解决以上问题。异常抛出规范// 这里表示这个函数会抛出A/B/C/D中的某种类型的异常void fun() throw(A，B，C，D);// 这里表示这个函数只会抛出bad_alloc的异常void* operator new (std::size_t size) throw (std::bad_alloc);更详细的观点链接： https://blog.csdn.net/mz474920631/article/details/125019151异常的几个缺点记一下：比较重要的 程序乱跳 C++没有垃圾回收，异常中没有正确处理申请的内存会很危险 C++标准库的异常体系其实有点乱 异常尽量规范使用，否则后果不堪设想，随意抛异常，外层捕获的用户苦不堪言。所以异常规范有两点：一、抛出异常类型都继承自一个基类。二、函数是否抛异常、抛什么异常，都使用 func（）throw();的方式规范化。"
    } 
  
]
