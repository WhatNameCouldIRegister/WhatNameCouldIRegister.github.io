[
  
    {
      "title"       : "毕业设计整理-1",
      "category"    : "",
      "tags"        : "c++, Parallel, Concurrent",
      "url"         : "./%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%95%B4%E7%90%86-2.html",
      "date"        : "2021-01-26 03:32:20 +0800",
      "description" : "cpp模板常见混淆点做一个自我区分",
      "content"     : "鉴于视频处理脚本开发已经基本完成本文专注于style-transfer网络训练部分基本概念以下内容转载自 https://blog.csdn.net/m0_54028213/article/details/127125842 输入中有一张内容图片（Content Image）和一张样式视频（Style Video） 模型所要训练的不是卷积神经网络的权重，而是合成图片，它是样式迁移过程中唯一需要更新的变量，即样式迁移所需迭代的参数模型深度神经网络凭借多个层逐级抽取图像的特征，因此可以选择其中某些层的输出作为内容特征或者样式特征（上图中的卷积神经网络第二层输出内容特征，第一层和第三层输出样式特征）选择其中某些层的输出作为内容特征或者样式特征（上图中的卷积神经网络第二层输出内容特征，第一层和第三层输出样式特征） 对于一张输入图片来讲，每一层的卷积神经网络都会有一个输出（特征），整个基于 CNN 的样式迁移的目的是训练出一张合成图片，使得合成图片和内容图片放进同样一个卷积神经网络的时候，合成图片在某一层的输出能够匹配上内容图片在某一层的损失（内容损失，Content Loss），即它们在内容上是相近的；同理，合成图片和内容图片所使用的是同一个卷积神经网络，在某些层的输出（特征）在样式上能够匹配的上。如果训练出一张合成图片同时满足以上需求的话，就可以认为它既保留了内容图片的内容，又保留了样式图片的样式一般来说，越靠近输入层，越容易抽取图片的细节信息；反之，越容易抽取图片的全局信息 为了避免合成图片过多地保留内容图片的细节，选择靠近输出的层（即内容层）来输出图片的内容特征 选择不同层的输出（即风格层）来匹配局部和全局的样式在使用卷积神经网络抽取特征时，只需要用到从输入层到最靠近输出层的内容层或者样式层之间的所有层 因为在训练的时候无需改变预训练的卷积神经网络的模型参数，所以可以在训练开始之前就提取出内容特征和风格特征通过前向传播（实线箭头方向）计算样式迁移的损失函数，并通过反向传播（虚线箭头方向）迭代模型参数，即不断更新合成图片关键点总结1、样式迁移常用的损失函数由 3 部分组成：内容损失、样式损失和全变分损失内容损失使合成图片与内容图片在内容特征上接近样式损失使合成图片与样式图片在样式特征上接近全变分损失有助于减少合成图片中的噪点2、可以通过预训练好的卷积神经网络来抽取图像的特征，并通过最小化损失函数来不断更新合成图片来作为模型参数3、使用格拉姆矩阵表达样式层输出的样式关于数据集MSCOCO数据集是微软开发维护的大型图像数据集，数据集标注类型对应任务包括物体检测、关键点检测、实例分割、 stuff分割 （没有特定形状的物体） ，全景分割人体关键点， 人体密度检测 等等。"
    } ,
  
    {
      "title"       : "毕业设计整理-1",
      "category"    : "",
      "tags"        : "c++, Parallel, Concurrent",
      "url"         : "./%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%95%B4%E7%90%86-1.html",
      "date"        : "2021-01-26 03:32:20 +0800",
      "description" : "cpp模板常见混淆点做一个自我区分",
      "content"     : "** 本篇进行视频处理脚本开发的逻辑疏导，以及附上关键代码 **** 本篇并不涉及神经网络训练部分，涉及部分是网络成型后的视频处理步骤 **准备使用的库 moviepy 鉴于视频的风格化的需求是含有两个主题，需要python库处理视频的裁剪和音频分离拼接 需要注意的是MoviePy常常用在比较复杂的视频处理操作上，包括音频视频分离、音频视频镶嵌、旋转拼接、音视频叠加等等。根据网上的建议，如果仅仅是简单的图像裁剪等等，不需要导入庞大的moviepy，用现有cv库的基本函数都能搞定 argparse 可以通过command line传入定制的参数，第一份脚本版本也许不会激活这个功能。现在目前的想法是通过命令行传入model_path\\input_image_path\\input_video_path concurrent 出于工程化目的，我决定使用多线程逻辑，采用该库的线程池：cocurrent.futures.ThreadPoolExecutor 脚本相关切割 sub_clip1 = video.subclip(0, 1/2 * time_len) sub_clip2 = video.subclip(1/2 * time_len, time_len) sub_clip1.write_videofile(temp_path1, fps = 30) sub_clip2.write_videofile(temp_path2, fps = 30)转换for frame in tqdm.tqdm(extract_frames(video_path), desc=\"Processing frames\"): # Prepare input frame image_tensor = Variable(transform(frame)).to(device).unsqueeze(0) # Stylize image with torch.no_grad(): stylized_image = transformer(image_tensor) # Add to frames stylized_frames += [deprocess(stylized_image)]帧处理# Create video from frames video_name = video_path.split(\"/\")[-1].split(\".\")[0] writer = skvideo.io.FFmpegWriter(f\"images/outputs/stylized-{video_name}.mp4\") for frame in tqdm.tqdm(stylized_frames, desc=\"Writing to video\"): writer.writeFrame(frame) writer.close() output_style_file_list.append(f\"images/outputs/stylized-{video_name}.mp4\")日志示范暂时进展 能够实现输入拍摄好的完整视频，脚本经过视频切割、通过读取不同模型路径，对视频风格进行转化，生成不同风格的视频片段然后进行合并，输出完整的、风格不同的视频TO DO &amp; 改进点 找到合适的数据集训练自己的模型 temp文件命名应该更灵活，不要固化 temp文件用完删除逻辑"
    } ,
  
    {
      "title"       : "cmake\make\makefile 整理",
      "category"    : "",
      "tags"        : "cmake",
      "url"         : "./cmake%E5%92%8Cmake.html",
      "date"        : "2021-01-26 03:32:20 +0800",
      "description" : "cpp模板常见混淆点做一个自我区分",
      "content"     : "文章结构参考自： https://zhuanlan.zhihu.com/p/111110992gcc GNU Compiler Collection (GNU编译套件)，可以直接理解成编译器，他可以编译的语言包括C、C++、Objective-C、Fortran、Java等等 如果编译少数文件时，可以利用gcc编译器的传入规则，传参规则直接进行编译选项、依赖项的配置、或者进行链接指示，编译器可以正常工作生成目标文件。 如果工程变的复杂，编译指南可能同时变得复杂，直接向compiler传参变得不现实。这个时候可以引入make工具make、makefile make 的凭证是makefile, 根据编写的makefile指引编译流程和依赖关系。make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。 makefile就是编译指引，在里面可以对需要使用的编译器进行指定，make命令按照makefile的指示逐步协调文件与依赖的关系，指引编译器编译 makefile在一些简单的工程完全可以人工拿下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改，这时候就出现了下面的Cmake这个工具。cmake cmake生成 makefile给make用，就这么简单 why cmake?更直白的语法，跨平台的兼容、更多样的编译指示，在实际工程中，我甚至在编译前先利用cmake运行准备工作的脚本 cmake更支持分支结构的导入，变量的设置与沿用，总之让编译工程的方式变得更加灵活。 cmake凭证式CmakeList.txt总结一下大体流程1.用编辑器编写源代码，如.c文件。2.用编译器编译代码生成目标文件，如.o。3.用链接器连接目标代码生成可执行文件，如.exe。但如果源文件太多，一个一个编译那得多麻烦啊？于是人们想到，为啥不设计一种类似批处理的程序，来批处理编译源文件呢？于是就有了make工具，它是一个自动化编译工具，你可以使用一条命令实现完全编译。但是你需要编写一个规则文件，make依据它来批处理编译，这个文件就是makefile，所以编写makefile文件也是一个程序员所必备的技能。对于一个大工程，编写makefile实在是件复杂的事，于是人们又想，为什么不设计一个工具，读入所有源文件之后，自动生成makefile呢，于是就出现了cmake工具，它能够输出各种各样的makefile或者project文件,从而帮助程序员减轻负担。但是随之而来也就是编写cmakelist文件，它是cmake所依据的规则。（cmake中有很多设置库的，此时还不是可执行文件，而make生成后才是二进制可执行文件。）所以在编程的世界里没有捷径可走，还是要脚踏实地的。"
    } ,
  
    {
      "title"       : "CPP并发编程整理(1)",
      "category"    : "",
      "tags"        : "c++, Parallel, Concurrent",
      "url"         : "./CPP%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%95%B4%E7%90%86-1.html",
      "date"        : "2021-01-26 03:32:20 +0800",
      "description" : "cpp模板常见混淆点做一个自我区分",
      "content"     : "文章主要内容摘自： https://paul.pub/cpp-concurrency/Why 并发编程 所有任务串行处理效率低下 虽然CPU处理频率在增长，但是终究会遇到突破的瓶颈。大家会发现曾经有过一段时间CPU的频率从3G到达4G，但在这之后就停滞不前了。因此最近的新款CPU也基本上都是3G左右的频率。相应的，CPU以更多核的形式在增长。目前的Intel i7有8核的版本，Xeon处理器达到了28核。并且，最近几年手机上使用的CPU也基本上是4核或者8核的了。掌握并发编程，可以真正地使处理器协调工作，并行完成任务，提高效率。关于并发和并行 并发concurrent，一段时间内执行多段任务，从宏观上来看是多任务同时完成的 并行parallel，在某一个时刻，有多个任务在实际上同时执行更严格的来说：如果一个系统支持多个动作同时存在，那么这个系统就是一个并发系统。如果这个系统还支持多个动作（物理时间上）同时执行，那么这个系统就是一个并行系统。你可能已经看出，“并行”其实是“并发”的子集。它们的区别在于是否具有多个处理器。如果存在多个处理器同时执行多个线程，就是并行。在不考虑处理器数量的情况下，我们统称之为“并发”。多线程一定能提升效率么？但我们需要知道，单纯的使用多线程并不一定能提升系统性能（当然，也并非线程越多系统的性能就越好）。从上面的两幅图我们就可以直观的感受到：线程（任务）的数量要根据具体的处理器数量来决定。假设只有一个处理器，那么划分太多线程可能会适得其反。因为很多时间都花在任务切换上了。CPP的并发编程知道cpp 11标准之前，c++标准库都没有对多线程编程的明确支持，如果在linux系统中需要使用linux的系统的api类似pthread_create来创建多线程环境，线程库叫POXIS THREAD编译器与C++标准编译器对于语言特性的支持是逐步完成的。想要使用特定的特性你需要相应版本的编译器。GCC对于C++特性的支持请参见这里：C++ Standards Support in GCC。Clang对于C++特性的支持请参见这里：C++ Support in Clang。关于cpp和gcc的版本对应关系，因为有线程库这样的类似的标志性变化，所以gcc的标志版本可以浅浅记一下 cpp gcc c++11 4.8 c++17 5.0 c++20 7.0 默认情况下编译器是以较低的标准来进行编译的，如果希望使用新的标准，你需要通过编译参数-std=c++xx告知编译器，例如： g++ -std=c++17 your_file.cpp -o your_program线程创建线程// 01_hello_thread.cpp#include &lt;iostream&gt;#include &lt;thread&gt; // ①using namespace std; // ②void hello() { // ③ cout &lt;&lt; \"Hello World from new thread.\" &lt;&lt; endl;}int main() { thread t(hello); // ④ t.join(); // ⑤ return 0;}thread可以和callable类型一起工作，因此如果你熟悉lambda表达式，你可以直接用它来写线程的逻辑，像这样：// 02_lambda_thread.cpp#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std;int main() { thread t([] { cout &lt;&lt; \"Hello World from lambda thread.\" &lt;&lt; endl; }); t.join(); return 0;}//传递参数给入口函数// 03_thread_argument.cppvoid hello(string name) { cout &lt;&lt; \"Welcome to \" &lt;&lt; name &lt;&lt; endl;}int main() { thread t(hello, \"https://paul.pub\"); t.join(); return 0;} 要注意参数是拷贝构造传入的，对于拷贝十分复杂的对象需要传指针引用，但是要注意对象的生存周期join 与 detach join：调用此接口时，当前线程会一直阻塞，直到目标线程执行完成（当然，很可能目标线程在此处调用之前就已经执行完成了，不过这不要紧）。因此，如果目标线程的任务非常耗时，你就要考虑好是否需要在主线程上等待它了，因此这很可能会导致主线程卡住。 detach：detach是让目标线程成为守护线程（daemon threads）。一旦detach之后，目标线程将独立执行，即便其对应的thread对象销毁也不影响线程的执行。并且，你无法再与之通信。其实意思应当是让其父进程成为0号的init进程，子进程的线程执行资源和状态由init负责释放 对于这两个接口，都必须是可执行的线程才有意义。你可以通过joinable()接口、查询是否可以对它们进行join或者detach。线程管理常用api api 作用 yield 任务快结束的时候希望出让处理器 get_id 返回当前线程id sleep_for 睡眠一定是时间 sleep_until 睡眠到指定时间 一次调用主要API|API|主要作用||—|—|| call_once | 即便在多线程环境下，也能保证只调用某个函数一次 || once_flag |与call_once配合使用 |在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化任务。这个时候就可以用到上面的接口。这个接口会保证，即便在多线程的环境下，相应的函数也只会调用一次。下面就是一个示例：有三个线程都会使用init函数，但是只会有一个线程真正执行它。// 05_call_once.cppvoid init() { cout &lt;&lt; \"Initialing...\" &lt;&lt; endl; // Do something...}void worker(once_flag* flag) { call_once(*flag, init);}int main() { once_flag flag; thread t1(worker, &amp;flag); thread t2(worker, &amp;flag); thread t3(worker, &amp;flag); t1.join(); t2.join(); t3.join(); return 0;}我们无法确定具体是哪一个线程会执行init。而事实上，我们也不关心，因为只要有某个线程完成这个初始化工作就可以了。"
    } ,
  
    {
      "title"       : "CPP模板机制（2）",
      "category"    : "",
      "tags"        : "c++, templates",
      "url"         : "./CPP%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6.html",
      "date"        : "2021-01-26 03:32:20 +0800",
      "description" : "cpp模板常见混淆点做一个自我区分",
      "content"     : "主要结构 source from https://blog.csdn.net/JAN6055/article/details/123801017本篇主要整理可变参数模板sizeof… 运算符template&lt;typename T, typename... Args&gt; void var_fun(const T &amp; t, const Args&amp;... args){ //cout &lt;&lt; t; cout &lt;&lt; \"element numbers of packs is \" &lt;&lt; sizeof...(Args); //var_fun(args...);}能够获得包中参数的个数关于包拓展是否对可变参数解析的省略号…用法存在疑虑？拓展 packs expand包拓展简单的来说将他分解为其构成的元素，如果说将参数变为包的过成类比为压缩未见，那么包拓展就是解压文件，但包拓展不仅仅是包展开。我们知道了拓展包就是解析包内的元素，解析元素的过程在cpp的编译器处理中可以理解成对包内的元素进行分解，并且进行平行的操作。解包，就是在相应的操作后面加上…，编译器的处理逻辑就如上所述。以下引用自原文的说法。 当拓展一个包时，我们还要提供用于，每个拓展元素的模式。拓展一个包就是将它分解为构成的元素，对每个元素应用模式，获得拓展后的列表。我们通过在模式右边防一个省略号…来触发拓展操作 。 什么是模式？在实际生活中，当我们说以一种模式打开某个东西，或者是什么模式打开时。指定的是固有的模式，比如说性能模式，均衡模式等。而包拓展的模式更像是对于每个元素都调用一次相应的函数，包拓展需要我们自定义模式——其实就是一个函数，返回值为包中的一个元素应用模式后的结果，所有这样的结果组合在一起，也就是包以这个模式（函数）展开。 以下引用自标准库的配置器展开noexcept(noexcept(::new((void *)__p) _Up(std::forward&lt;_Args&gt;(__args)...)))另外，一定要注意省略号的位置，省略号的位置直接表述了对应解包的操作以及如何解包var_func(args...); //默认的包展开//注释部分的...不为关键字，和C++语法没有任何关系//相当于这样{ele1, ele2, ele3, ... ,elen}var_fun(mul(2,args)...); //带有模式的包展开//第二种展开模式相当于这样//{ mul(2,ele0),mul(2,ele1),mul(2,ele2), ... mul(2,elen) }所以其实并没有说…只能用于哪些函数和操作在现代cpp中，…就代表了解包操作，编译器会根据…的使用来平行地应用模式还有个小细节，当你需要解包，…放在后面，当你为了压缩（其实可以类比一下，意思就是声明模板的传包形式时或者声明函数的可变参数传入形式时，…放在类似Args参数或者形式参数args前，注意仅仅是在参数前，在其他符号之后）demotemplate &lt;typename T&gt;void print(const T &amp; t){ cout &lt;&lt; t &lt;&lt; endl;}template &lt;typename T, typename... Args&gt;void print(const T &amp;t ,const Args... args){ cout &lt;&lt; t &lt;&lt; endl; print(args...);} template &lt;typename T&gt;int up(T &amp; t){ t *= 2; return t;}template &lt;typename... Args&gt;void func(Args&amp;&amp;... args){ print(up(args)...);} int main(){ func(1,2,3,4,5); return 0;}使用std::forward要说转发一定离不开std::forwardforward返回实参类型的右值引用。它和move很像，但前者是返回给定类型的右值引用，如果给定的类型是左值引用也返回其右值引用——左值引用，并且其必须显式的指定模板参数；而move无论模板参数类型是什么都返回一个右值引用（只能是右值引用），因为前面已经看到了move的实现方法。于是我们可以定义下面的转发函数template &lt;typename F, typename T1, typename T2&gt;void fun(F f, T1 &amp;&amp; t1, T2 &amp;&amp; t2){ f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));}使用右值引用作为模板参数——确保接受任意对象，并保证其能保持原来的性质不变（见引用折叠）。在发送参数的过程中获得对应类型的右值——确保其传递给函数的参数的性质不变（见引用折叠）。转发参数包根据上面转发的关键字，我们可以知道，在进行转发的时候应该以何种模式进行包展开。template&lt;typename ... Args&gt;void buffer_fun(Args &amp;&amp;... args){ work(std::forward&lt;Args&gt;(args)...);}"
    } ,
  
    {
      "title"       : "CPP模板机制（1）",
      "category"    : "",
      "tags"        : "c++, templates",
      "url"         : "./CPP%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6.html",
      "date"        : "2021-01-26 03:32:20 +0800",
      "description" : "cpp模板常见混淆点做一个自我区分",
      "content"     : "主要结构 source from https://blog.csdn.net/JAN6055/article/details/123801017模板的声明方式// some demotemplate &lt;typename T&gt;T func(T A) { ...}templte &lt;typename T, template A&gt; T func(A a, T t) { ...}template &lt;typename T&gt;class A {};//可变参数模板template &lt;typename T, typename... Args&gt; T func(T a, Args...) {}关于模板的工作机制 首先我们要明确模板常常定义在头文件中，而由此也能练习到许多模板的作用机制。 模板定义并不是真正的定义了一个函数或者类，而是编译器根据程序员缩写的模板和形参来自己写出一个对应版本的定义，这个过程叫做模板实例化。 编译器成成的版本通常被称为模板的实例。编译器为程序员生成对应版本的具体过程。类似宏替换。模板类在没有调用之前是不会生成代码的。 模板的实例化凭证是编译器遇到对模板的使用时才会生成相应版本的代码，这个时间是编译期 为什么模板要放在头文件？试想当放在源文件中，当源文件中使用到模板代码，而模板定义在其他源文件中，那么此源文件无法找到函数地址，只能等待连接时刻。那如果其他源文件中不存在对模板的特定版本实例化代码怎么办呢？那么函数重定位就会失败，模板机制就会收到影响非类型模板参数顾名思义，模板参数不是一个类型而是一个具体的值——这个值是常量表达式。当一个模板被实例化时，，非类型参数被一个用户提供的或者编译器推断出的值所代替。正因为模板在编译阶段编译器为我们生成一个对应的版本，所以其值应该能够编译时确定，那么他应该是一个常量或者常量表达式。有一句话说：C++的强大在于他的编译器强大，下面这个例子就是很好的说明。template &lt;size_t N, size_t M&gt;int str_compare(const char (&amp;str1)[N], const char (&amp;str2)[M]){ return strcmp(str1,str2);}模板默认参数template &lt;typename T = int&gt;class A {};//如果像下例实例化的模板默认A&lt;int&gt;类型A&lt;&gt; a;类模板已经声明，而成员函数希望在模板外实现的做法template &lt;typename T&gt; class A { ... T func(T a) { ... } ...};//模板外实现template &lt;typename T&gt;T A::func(T a) {}关于模板类的的模板成员我已经不知道用什么语言来下面的代码了。但是我们知道了一些事情。无论是定义还是声明，模板语法的优先级是最高的，不同模板的优先级又根据其声明顺序来判断，其次是函数修饰，然后是返回值。根据这个原则我们可以轻松的解析这个函数。template &lt;typename T&gt; class A{public: template &lt;typename It&gt; A&lt;T&gt; sum(It _begin, It _end);}; template &lt;typename T&gt; //最外层模板template &lt;typename It&gt; //内层模板A&lt;T&gt; //返回值A&lt;T&gt;::sum(It _begin, It _end)//函数标签 {} //算法实现 //不妨写的更美观一点template &lt;typename T&gt; template &lt;typename It&gt; A&lt;T&gt; A&lt;T&gt;::sum(It _begin, It _end){ }模板实例化优化 我们知道模板的实例化通常是以头文件为凭据，生成实例化代码，类似宏定义，那么当多个文件中都用到同样实例的代码就会存在多份函数拷贝 解决这个问题，我们可以使用extern关键字,声明extern顾名思义就是告诉编译器在其他位置有相同的拷贝，请在链接阶段解决这个问题//导入其他文件中的模板实例extern template class A&lt;T&gt;//定义具体方式template &lt;typename T&gt;class B {}遇到类型转换的时候会如何决策 纵眼cpp，关于类型转换，我很赞同原文结构参考作者的观点：在转换是安全的情况下更有可能发生 最经典的例子无非是 non-const 到 const 的转换 下例中参数a的int会被增提转化为 const int, T推导为inttemplate&lt;typename T&gt; bool func(const T t1, const T t2){ return less&lt;T&gt;()(t1,t2);} ... int a = 10; const int b = 20; func&lt;int&gt;(a,b);这里的int转为cosnt int是允许的，因为这是按值传递，并且non-const 转为 cosnt也不会带来什么坏处。因此，编译器会执行这样的转换。我们不妨修改一下这个函数bool func(const T &amp; t1, const T &amp; t2);bool func(T &amp; t1, T &amp; t2);上述第一个声明会正常调用——虽然是引用，和上面的是同样的道理。而第二个却不会正常调用——因为b是一个cosnt 将要转换为non-const，我中转换是不安全的，所以编译不允许这样的转换。假设我们这样调用两个函数func&lt;int&gt;(10,20);同样的，对于第一个是允许的——虽然讲右值绑定到左值引用上，但是我们用const修饰形参，保证其不会改变，所以编译器同意这样的转换。而对于第二个，编译器则不允许这样的转换，因为我们的形参是non-const的，不能保证不修改形参的值，形参正好又是一个引用，这样可以修改实参的值——恰好实参是一个右值——是不允许被修改的，所以编译器不允许这样的转换。基于上面的转换规则，我们可以知道，如果函数形参不是引用类型，则可以对数组或者函数类型的实参应用正常的指针转换。模板实参推断直接上demotemplate &lt;typename T&gt; void func1(T &amp;) { }template &lt;typename T&gt; void func2(const T &amp;) { }void demo() { int a = 1 const int b = 2; func1(a); //T is int func1(b); //T is const int func2(a); //T is int func2(b); //T is int func2(10); //T is int }右值引用，引用折叠,万能引用// 关于万能引用template &lt;typename T&gt;void func(T &amp;&amp;a) { ...}int a=10;func(10); //T被推导为intfunc(a); //T被推导成int&amp; 关于折叠和万能引用众所周知在非模板函数中可以使用const &amp; 来接受任意类型参数，在模板中，也有类似这样的万能引用，就是&amp;&amp;。知道了这样的原因是有着引用折叠得的存在。先说结论：在传递参数的过程中，无论多么复杂的引用传参，最后都会被折叠为&amp; 或者 &amp;&amp;。这也就是引用折叠，引用折叠可以被概述成下列如果我们间接创建了一个引用的引用，则这些引用形成折叠。除了右值引用的右值引用会被折叠为一个右值引用，剩下全部折叠为一个左值引用。即T&amp; &amp;, T&amp; &amp;&amp;， T&amp;&amp; &amp;都会折叠为T&amp;T&amp;&amp; &amp;&amp;会被折叠为&amp;&amp;这两个规则又暗示了我们——我们可以将任意类型的实参传递给参数为右值引用的函数。关于模板，上述的规则可以被统一为如果一个函数参数是一个指向模板类型参数的右值引用，则他可以被绑定到一个左值。如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数将被参数将被实例化为一个普通左值引用参数。std::move直接上std::move定义template &lt;typename T&gt;typename remove_reference&lt;T&gt;::type &amp;&amp; move(T &amp;&amp; t){ return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t); }std::move通过用法我们知道它可以接受任何对象，因此他应当是一个模板。模板特例化我们编写的模板，不可能保证对于所有的类型都能适用——compare函数就是很经典的例子，对于两个指针类型，仅仅是毫无意义的比较。这时候我们用到模板特例化的技术可以很好的解决这样的问题。其实意思就是说，同一份类似宏定义的模板代码不一定能适配于所有版本的由于less的底层是使用&lt;来比较的，所以less并没有适配字符指针。那么，我们可以编写这样的模板特例化。template &lt;&gt; //表示一个模板特例化——语法规定int compare(const char * const &amp; str1, const char * const &amp; str2) //具体的类型{ return strcmp(str1,str2);}特例化和重载的区别特例化就是一个特殊的实例化——模板的实例化，所以，特例化仅仅是模板的一个实例化，不会影响函数匹配。并且，模板特例化一定要保证模板的之前的声明或者定义。如果不这样做——编译器不会报错，但是会有一些令人匪夷所思的地方。模板会由编译器实例化，而不是调用自己特例化版本——这种错误往往很难查找。所以，记住一个规则：特例化一个模板，一定要保证其在原模板的定义域中。部分模板特例化“针对模板参数更进一步的条件限制所设计出来的一个特化版本” （摘自《泛型思维》） demo //general templatetemplate&lt;class T1, class T2&gt; class Pair { ... }; //specialization with T2 set to inttemplate&lt;class T1&gt;class Pair&lt;T1, int&gt; { ... }; 下一篇聚焦可变参数模板…"
    } ,
  
    {
      "title"       : "关于虚函数的一些再确认",
      "category"    : "",
      "tags"        : "c++, coding",
      "url"         : "./%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E7%90%86%E8%A7%A3.html",
      "date"        : "2021-01-26 03:32:20 +0800",
      "description" : "Single neuron perceptron that classifies elements learning quite quickly.",
      "content"     : "虚函数表是类的 类的每个对象前四个字节就是指向虚函数表的指针 虚函数表的内容是指向函数的指针父类指针指向子类对象。运行时动态多态机制。指针指向的内存地址是派生类，根据派生类对象前四个字节找到虚函数表指针，根据虚函数表指针找到虚函数表从而调用函数哪些函数不能被声明为虚函数常见的不不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。为什么C++不支持普通函数为虚函数？普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。为什么C++不支持构造函数为虚函数？这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。 构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成，所以不能将构造函数定义为虚函数。为什么C++不支持内联成员函数为虚函数？其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数） 内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数。为什么C++不支持静态成员函数为虚函数？这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。 静态成员函数属于一个类而非某一对象，没有this指针，它无法进行对象的判别。 为什么C++不支持友元函数为虚函数？ 因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。"
    } ,
  
    {
      "title"       : "STL相关的一些面试遭遇",
      "category"    : "",
      "tags"        : "c++, STL, coding",
      "url"         : "./STL%E7%9A%84%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93.html",
      "date"        : "2021-01-26 03:32:20 +0800",
      "description" : "面试遇到的一些容器库的问题，持续更新",
      "content"     : "STL的主要组成容器、算法、迭代器resize和reverse的区别 改变的容器度量不一样。 resize改变的是容器的size, 如果size大于容器原来的size，则扩大容器空间（size）并且将扩大的空间初始化 reverse改变的是容器的capacity，要知道cap和size不是一个概念，cap表征容器已经开辟的空间，size代表元素的数量。cap理论上是大于等于size的，reverse的传参小于size的时候不会有事情发生，大于size的时候将capacity变化到传入参数指定的大小 两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。vector中at()和【】访问区别at会检查下标范围，【】访问如果下表越界会造成对内存的非法访问，at()更加安全。at() 函数抛出的应当是std::out_of_range错误"
    } ,
  
    {
      "title"       : "CPP异常知识碎片",
      "category"    : "",
      "tags"        : "c++, exeption",
      "url"         : "./CPP%E5%BC%82%E5%B8%B8%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87.html",
      "date"        : "2021-01-26 03:32:20 +0800",
      "description" : "CPP异常处理的处理逻辑与种类",
      "content"     : "图片取自csdn @任我驰骋首先异常全部继承自std::exception类抓几个重要的来说，std::bad_alloc在表征内存开辟错误std::bad_cast 主要是dynamic_cast过程中抛出的错误。logic_error 溢出、语义错误等std::runtime_error 运行时错误，溢出错误 std::overflow_over std::range_error …异常捕捉的标准凭证是throw()//异常处理标准流程try {} catch (Exception &amp;) {}关于异常处理的标准流程： 首先检查throw是否本身在try语句块内 如果在则选择匹配的catch进行处理，如果没有找到匹配的catch或者本函数调用没有存在异常处理，递归地退出当前函数帧栈寻找catch解决， 直到退出到main函数层面，如果依然没有匹配的处理模块那么就终止程序异常安全构造函数完成对象的构造和初始化，最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有完全初始化析构函数主要完成资源的清理，最好不要在析构函数内抛出异常，否则可能导致资源泄漏(内存泄漏、句柄未关闭等)C++中异常经常会导致资源泄漏的问题，比如在new和delete中抛出了异常，导致内存泄漏，在lock和unlock之间抛出了异常导致死锁，C++经常使用RAII来解决以上问题。异常抛出规范// 这里表示这个函数会抛出A/B/C/D中的某种类型的异常void fun() throw(A，B，C，D);// 这里表示这个函数只会抛出bad_alloc的异常void* operator new (std::size_t size) throw (std::bad_alloc);更详细的观点链接： https://blog.csdn.net/mz474920631/article/details/125019151异常的几个缺点记一下：比较重要的 程序乱跳 C++没有垃圾回收，异常中没有正确处理申请的内存会很危险 C++标准库的异常体系其实有点乱 异常尽量规范使用，否则后果不堪设想，随意抛异常，外层捕获的用户苦不堪言。所以异常规范有两点：一、抛出异常类型都继承自一个基类。二、函数是否抛异常、抛什么异常，都使用 func（）throw();的方式规范化。"
    } 
  
]
